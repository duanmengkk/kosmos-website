"use strict";(self.webpackChunkzfile_docs=self.webpackChunkzfile_docs||[]).push([[143],{3008:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var r=n(4848),i=n(8453);const s={id:"mcs-discovery",title:"Multi-cluster Service Discovery"},o="Multi-cluster Service Discovery",l={id:"v0.2.0/tutorials/mcs-discovery",title:"Multi-cluster Service Discovery",description:"Kosmos provides two capabilities for multi-cluster service discovery:",source:"@site/docs/v0.2.0/tutorials/multi-cluster-svc-discovery.md",sourceDirName:"v0.2.0/tutorials",slug:"/v0.2.0/tutorials/mcs-discovery",permalink:"/website/v0.2.0/tutorials/mcs-discovery",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/v0.2.0/tutorials/multi-cluster-svc-discovery.md",tags:[],version:"current",frontMatter:{id:"mcs-discovery",title:"Multi-cluster Service Discovery"},sidebar:"tutorialSidebar",previous:{title:"Quick Start",permalink:"/website/v0.2.0/quick-start"},next:{title:"Multi-cluster Scheduler",permalink:"/website/v0.2.0/tutorials/mc-scheduler"}},a={},c=[{value:"Distributed Multi-Cluster Service Solution",id:"distributed-multi-cluster-service-solution",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Install Kosmos",id:"install-kosmos",level:4},{value:"Join the Leaf Cluster",id:"join-the-leaf-cluster",level:4},{value:"Using Distributed Multi-Cluster Service",id:"using-distributed-multi-cluster-service",level:3},{value:"Manual Exporting and Importing of Service",id:"manual-exporting-and-importing-of-service",level:4},{value:"Automatic Exporting and Importing of Service to all Data Plane Clusters",id:"automatic-exporting-and-importing-of-service-to-all-data-plane-clusters",level:3},{value:"Annotation-based Recognition via Control Plane Service",id:"annotation-based-recognition-via-control-plane-service",level:4},{value:"Global Startup Parameters",id:"global-startup-parameters",level:4},{value:"Service Cross-Cluster Network Connectivity Verification",id:"service-cross-cluster-network-connectivity-verification",level:3},{value:"Global Centralized Core-DNS Solution",id:"global-centralized-core-dns-solution",level:2},{value:"Introduction",id:"introduction-1",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"multi-cluster-service-discovery",children:"Multi-cluster Service Discovery"})}),"\n",(0,r.jsx)(t.p,{children:"Kosmos provides two capabilities for multi-cluster service discovery:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Distributed multi-cluster service solution"}),"\n",(0,r.jsx)(t.li,{children:"Global centralized core-dns solution. Among them, in production environments, we recommend the decentralized distributed multi-cluster service solution."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"distributed-multi-cluster-service-solution",children:"Distributed Multi-Cluster Service Solution"}),"\n",(0,r.jsx)(t.h3,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(t.p,{children:"Kosmos implements multi-cluster service discovery based on the Multi-Cluster Service API. Users can export services generated by the control plane cluster to member clusters, thereby providing services externally in member clusters."}),"\n",(0,r.jsx)(t.admonition,{title:"NOTE",type:"info",children:(0,r.jsx)(t.p,{children:"To use this feature, ensure that the control plane cluster and member clusters have a version of at least v1.21, and the version of core-dns in the cluster is not less than v1.84."})}),"\n",(0,r.jsx)(t.p,{children:"The architecture of Kosmos' distributed multi-cluster service solution is as follows."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"MCS Architecture.svg",src:n(265).A+"",width:"1185",height:"671"})}),"\n",(0,r.jsx)(t.p,{children:"Kosmos' controller monitors the ServiceExport and ServiceImport resources of the control plane and data plane, and synchronizes the Service and EndpointSlice from the control plane to the data plane cluster based on the configuration of these two MCS resources. In any data plane cluster, services can be exposed externally through Service, and each data plane cluster's EndpointSlice will contain all Pod IPs of the workloads in the control plane cluster, achieving cross-cluster multi-active services across different locations."}),"\n",(0,r.jsx)(t.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsx)(t.h4,{id:"install-kosmos",children:"Install Kosmos"}),"\n",(0,r.jsxs)(t.p,{children:["Refer to the Kosmos Quick Start documentation ",(0,r.jsx)(t.a,{href:"https://github.com/kosmos-io/kosmos",children:"https://github.com/kosmos-io/kosmos"})," and enable the ClusterLink module for multi-cluster networking. Using the kosmosctl tool:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",metastring:"script",children:"kosmosctl install --cni calico --default-nic eth0 (We build a network tunnel based on the network interface value passed by the arg default-nic)\n"})}),"\n",(0,r.jsx)(t.h4,{id:"join-the-leaf-cluster",children:"Join the Leaf Cluster"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",metastring:"script",children:"kosmosctl join cluster --name cluster1 --kubeconfig ~/kubeconfig/cluster1-kubeconfig --cni calico --default-nic eth0 --enable-link\n"})}),"\n",(0,r.jsx)(t.h3,{id:"using-distributed-multi-cluster-service",children:"Using Distributed Multi-Cluster Service"}),"\n",(0,r.jsx)(t.h4,{id:"manual-exporting-and-importing-of-service",children:"Manual Exporting and Importing of Service"}),"\n",(0,r.jsx)(t.p,{children:"Users can manually create ServiceExport and ServiceImport to distribute services to data plane clusters."}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Create a nginx workload in the data plane cluster, the nginx yaml is as follows:"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",metastring:"script",children:'apiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: nginx\r\nspec:\r\n  replicas: 2\r\n  selector:\r\n    matchLabels:\r\n      app: nginx\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: nginx\r\n    spec:\r\n      tolerations:\r\n        - key: "kosmos.io/node"\r\n          operator: "Equal"\r\n          value: "true"\r\n          effect: "NoSchedule"\r\n        podAntiAffinity:\r\n          requiredDuringSchedulingIgnoredDuringExecution:\r\n            - labelSelector:\r\n                matchLabels:\r\n                  app: nginx\r\n              topologyKey: kubernetes.io/hostname\r\n      containers:\r\n        - name: nginx\r\n          image: nginx:latest\r\n          ports:\r\n            - containerPort: 80\r\n---\r\napiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  name: nginx\r\nspec:\r\n  selector:\r\n    app: nginx\r\n  ports:\r\n    - protocol: TCP\r\n      port: 80\r\n      targetPort: 80\r\n      nodePort: 31444\r\n  type: NodePort\n'})}),"\n",(0,r.jsx)(t.admonition,{title:"NOTE",type:"info",children:(0,r.jsx)(t.p,{children:"The workload's pods can be scheduled to Kosmos' leaf nodes by specifying node affinity in the yaml."})}),"\n",(0,r.jsxs)(t.ol,{start:"2",children:["\n",(0,r.jsx)(t.li,{children:"Create a ServiceExport in the control plane to export the nginx Service:"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",metastring:"script",children:"apiVersion: multicluster.x-k8s.io/v1alpha1\r\nkind: ServiceExport\r\nmetadata:\r\n  name: nginx\n"})}),"\n",(0,r.jsxs)(t.ol,{start:"3",children:["\n",(0,r.jsx)(t.li,{children:"Create a ServiceImport in data plane cluster 1 to import the exported Service:"}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",metastring:"script",children:"apiVersion: multicluster.x-k8s.io/v1alpha1\r\nkind: ServiceImport\r\nmetadata:\r\n  name: nginx\r\nspec:\r\n  type: ClusterSetIP\r\n  ports:\r\n    - protocol: TCP\r\n      port: 80\n"})}),"\n",(0,r.jsx)(t.p,{children:"At this point, the service can be exposed externally in data plane cluster 1 using the same Service."}),"\n",(0,r.jsx)(t.h3,{id:"automatic-exporting-and-importing-of-service-to-all-data-plane-clusters",children:"Automatic Exporting and Importing of Service to all Data Plane Clusters"}),"\n",(0,r.jsx)(t.p,{children:"In some scenarios, users need to automatically synchronize the control plane's Service to all data plane clusters without manually creating ServiceExport and ServiceImport. Kosmos provides two methods for automatic export and import of Service."}),"\n",(0,r.jsx)(t.h4,{id:"annotation-based-recognition-via-control-plane-service",children:"Annotation-based Recognition via Control Plane Service"}),"\n",(0,r.jsxs)(t.p,{children:["For services that need to be automatically exported and distributed to all data plane clusters, users can manually add an annotation to the Service: ",(0,r.jsx)(t.code,{children:'kosmos.io/auto-create-mcs: "true"'}),". An example service yaml is as follows:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",metastring:"script",children:'apiVersion: v1\r\nkind: Service\r\nmetadata:\r\n  name: nginx\r\n  annotations:\r\n    kosmos.io/auto-create-mcs: "true"\r\nspec:\r\n  selector:\r\n    app: nginx\r\n  ports:\r\n    - protocol: TCP\r\n      port: 80\r\n      targetPort: 80\r\n      nodePort: 31444\r\n  type: NodePort\n'})}),"\n",(0,r.jsx)(t.h4,{id:"global-startup-parameters",children:"Global Startup Parameters"}),"\n",(0,r.jsxs)(t.p,{children:["For cases where code modification is not desired, Kosmos also supports automatic distribution of services by configuring startup parameters. Add the parameter ",(0,r.jsx)(t.code,{children:"--auto-mcs-prefix"})," to the ClusterTree startup service, for example, configuring ",(0,r.jsx)(t.code,{children:"--auto-mcs-prefix=test"}),", kosmos will automatically export services under namespaces with the test and kosmos prefixes to all data plane clusters."]}),"\n",(0,r.jsx)(t.h3,{id:"service-cross-cluster-network-connectivity-verification",children:"Service Cross-Cluster Network Connectivity Verification"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"eps-probe-plugin"})," is a plugin for cross-cluster service network verification. As mentioned above, Kosmos' controller synchronizes the Service and EndpointSlice from the control cluster to the data plane cluster. When there is a network connectivity failure across clusters, the endpoints in the EndpointSlice become unreachable, leading to malfunction."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"eps-probe-plugin"})," checks whether the pod-ips in the endpoint are reachable on a regular basis. It updates the addresses of unreachable endpoints to ",(0,r.jsx)(t.code,{children:'"kosmos.io/disconnected-address"'})," in serviceImport. The Kosmos controller will remove the unreachable endpoints from the exported Service's corresponding EndpointSlice."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"eps-probe-plugin"})," can be installed using the following command:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",metastring:"script",children:"kubectl apply -f https://raw.githubusercontent.com/kosmos-io/eps-probe-plugin/main/deploy/eps-probe-plugin.yaml\n"})}),"\n",(0,r.jsx)(t.h2,{id:"global-centralized-core-dns-solution",children:"Global Centralized Core-DNS Solution"}),"\n",(0,r.jsx)(t.h3,{id:"introduction-1",children:"Introduction"}),"\n",(0,r.jsx)(t.p,{children:"The global centralized core-dns solution is shown in the diagram below. All pods distributed through Kosmos are resolved through the core-dns of the control plane cluster. This approach is only suitable for testing environments and may cause excessive request load on the core-dns of the control plane cluster in production environments."}),"\n",(0,r.jsxs)(t.p,{children:["To enable the global centralized core-dns solution, simply modify the startup parameter of the clusterTree service to ",(0,r.jsx)(t.code,{children:"--multi-cluster-service=false"}),"."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"CoreDNS_Centralized_Architecture.svg",src:n(294).A+"",width:"1073",height:"672"})})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},294:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/CoreDNS_Centralized_Architecture-5d5c0d8887c8ff26ae63bcc7d10a7fe8.svg"},265:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/MCS_Architecture-9279013ec1847fc33c86d989475a809e.svg"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var r=n(6540);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);