"use strict";(self.webpackChunkzfile_docs=self.webpackChunkzfile_docs||[]).push([[33],{6732:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var s=t(4848),i=t(8453);const o={id:"pv-pvc-dynamic-storage",title:"Multi-cluster PV/PVC Dynamic Storage"},r="Multi-cluster PV/PVC Dynamic Storage Solution",l={id:"v0.2.0/tutorials/pv-pvc-dynamic-storage",title:"Multi-cluster PV/PVC Dynamic Storage",description:"Multi-cluster PV/PVC Dynamic Storage Implementation",source:"@site/docs/v0.2.0/tutorials/pv-pvc-dynamic-storage.md",sourceDirName:"v0.2.0/tutorials",slug:"/v0.2.0/tutorials/pv-pvc-dynamic-storage",permalink:"/website/v0.2.0/tutorials/pv-pvc-dynamic-storage",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/v0.2.0/tutorials/pv-pvc-dynamic-storage.md",tags:[],version:"current",frontMatter:{id:"pv-pvc-dynamic-storage",title:"Multi-cluster PV/PVC Dynamic Storage"},sidebar:"tutorialSidebar",previous:{title:"Multi-cluster Network Connectivity",permalink:"/website/v0.2.0/tutorials/mcn-connectivity"},next:{title:"Design of EXEC and Log in Kosmos",permalink:"/website/v0.2.0/tutorials/exe-and-log"}},a={},c=[{value:"Multi-cluster PV/PVC Dynamic Storage Implementation",id:"multi-cluster-pvpvc-dynamic-storage-implementation",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Approach",id:"approach",level:3},{value:"Roles of PVC, PV, and SC in A Single Kubernetes Cluster",id:"roles-of-pvc-pv-and-sc-in-a-single-kubernetes-cluster",level:4},{value:"PVC, PV, StorageClass Implementation Process in A Single Kubernetes Cluster",id:"pvc-pv-storageclass-implementation-process-in-a-single-kubernetes-cluster",level:4},{value:"StorageClass Volume Binding Modes",id:"storageclass-volume-binding-modes",level:4},{value:"CSI (Dynamic Volume Provisioning) Related Process",id:"csi-dynamic-volume-provisioning-related-process",level:4},{value:"Across-clusters Implementation",id:"across-clusters-implementation",level:4},{value:"Flow",id:"flow",level:3},{value:"Related",id:"related",level:3},{value:"Scheduling Module (Host-Cluster)",id:"scheduling-module-host-cluster",level:4},{value:"Orchestration Module",id:"orchestration-module",level:4},{value:"Demo",id:"demo",level:3},{value:"Conclusion",id:"conclusion",level:3}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"multi-cluster-pvpvc-dynamic-storage-solution",children:"Multi-cluster PV/PVC Dynamic Storage Solution"})}),"\n",(0,s.jsx)(n.h2,{id:"multi-cluster-pvpvc-dynamic-storage-implementation",children:"Multi-cluster PV/PVC Dynamic Storage Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"This document mainly introduces the implementation of PV/PVC storage management for stateful service-related Pods in Kosmos across clusters.\r\nIt provides a detailed explanation of the processes involved in creating, updating, and binding PV and PVC for Pods.\r\nThrough this document, you can gain a comprehensive understanding of the details of managing stateful services in Kosmos."}),"\n",(0,s.jsx)(n.admonition,{title:"NOTE",type:"info",children:(0,s.jsx)(n.p,{children:"The current implementation is an intermediate version, and further optimization will be done for global storage."})}),"\n",(0,s.jsx)(n.h3,{id:"approach",children:"Approach"}),"\n",(0,s.jsx)(n.h4,{id:"roles-of-pvc-pv-and-sc-in-a-single-kubernetes-cluster",children:"Roles of PVC, PV, and SC in A Single Kubernetes Cluster"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Persistent Volume (PV):"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"PV is a storage volume resource in a Kubernetes cluster that abstracts and separates it from the actual storage backend."}),"\n",(0,s.jsx)(n.li,{children:"PV can be any form of storage, such as network storage, local storage, cloud storage, etc."}),"\n",(0,s.jsx)(n.li,{children:"PVs can be pre-created by the PV administrator or dynamic storage plugins in the cluster. They can also be dynamically created to fulfill the requirements of PVC."}),"\n",(0,s.jsx)(n.li,{children:"PV describes storage attributes such as capacity, access modes (e.g., read/write), and reclaim policies."}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Persistent Volume Claim (PVC):"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"PVC is the application's request for storage resources. It specifies the required storage capacity and other properties, such as access modes and volume modes, in the Pod."}),"\n",(0,s.jsx)(n.li,{children:"Applications use PVC to declare their storage requirements without specifying the actual storage location or type. Kubernetes matches PVC requirements with available PVs in the cluster to fulfill the PVC's needs."}),"\n",(0,s.jsx)(n.li,{children:"PVC can request dynamically provisioned matching PVs or manually select specific PV objects."}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"StorageClass (SC):"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"SC defines the dynamic provisioning strategy for PVs. It specifies how to automatically create PVs based on PVC requirements."}),"\n",(0,s.jsx)(n.li,{children:"When a PVC requests a specific StorageClass, Kubernetes creates PV according to the rules defined in the StorageClass and automatically binds the PV to the PVC."}),"\n",(0,s.jsx)(n.li,{children:"StorageClass allows different types of storage to be defined, providing different storage options for different applications."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"pvc-pv-storageclass-implementation-process-in-a-single-kubernetes-cluster",children:"PVC, PV, StorageClass Implementation Process in A Single Kubernetes Cluster"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When a Pod in the application needs access to persistent storage, a PVC object is created to declare the desired storage."}),"\n",(0,s.jsx)(n.li,{children:"Based on the requirements defined in the PVC, Kubernetes matches it with suitable PVs through the StorageClass and binds them."}),"\n",(0,s.jsx)(n.li,{children:"After successful binding between PV and PVC, the application can directly use the storage provided by PVC and mount the storage path in the Pod."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"storageclass-volume-binding-modes",children:"StorageClass Volume Binding Modes"}),"\n",(0,s.jsx)(n.p,{children:"The 'volumeBindingMode' field in StorageClass definition specifies how the dynamic provisioner binds PVC and PV.\r\nHere are several common volume binding modes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Immediate: In this mode, the provisioner immediately binds an available PV to the PVC. If there are no available PVs matching the requirements of the PVC, the PVC remains in the Pending state."}),"\n",(0,s.jsx)(n.li,{children:"WaitForFirstConsumer: In this mode, the provisioner waits until a Pod referencing the PVC attempts to mount the volume before allocating a PV. The PV is dynamically bound when the PVC is consumed by the Pod."}),"\n",(0,s.jsx)(n.li,{children:"Cluster: This is the default binding mode. PV is immediately assigned to PVC. This mode is similar to 'Immediate', but it allows the cluster administrator to override the default binding mode of StorageClass. Each StorageClass can have only one binding mode, and once set, it cannot be changed."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Choose the appropriate binding mode based on your needs and environment configuration."}),"\n",(0,s.jsx)(n.h4,{id:"csi-dynamic-volume-provisioning-related-process",children:"CSI (Dynamic Volume Provisioning) Related Process"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"User creates a Pod + PVC."}),"\n",(0,s.jsx)(n.li,{children:"The VolumeController's PersistentVolumeController control loop detects the creation of PVC and skips it since it uses the Out-of-Tree mode.\r\nThis control loop mainly handles PV and PVC binding in the In-Tree mode."}),"\n",(0,s.jsx)(n.li,{children:"External-provisioner detects the creation of PVC:"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Calls the 'CreateVolume' method of the Controller Service to create the underlying storage volume.\r\nAt this point, the volume is in the CREATED state and exists only in the storage system, not visible to any nodes or containers."}),"\n",(0,s.jsx)(n.li,{children:"Creates PV."}),"\n",(0,s.jsx)(n.li,{children:"Binds the PV to the PVC (binding: fills the name of this PV object in the spec.volumeName field of the PVC object)."}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"The VolumeController's AttachDetachController control loop detects that the volume is not attached to the host and needs an Attach operation.\r\nIt creates the 'VolumeAttachment' object."}),"\n",(0,s.jsx)(n.li,{children:"When the external-attacher detects the creation of the 'VolumeAttachment' resource, it calls the 'ControllerPublishVolume' method of the Controller Service.\r\nAt this point, the volume is in the NODE_READY state, meaning the Node can detect the volume but it is still invisible inside the container."}),"\n",(0,s.jsx)(n.li,{children:"The Kubelet's VolumeManagerReconciler control loop:"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Performs the MountDevice operation by calling the 'NodeStageVolume' method of the Node Service.\r\nThis method mainly handles formatting the volume and mounting it to a temporary directory (Staging directory).\r\nAfter this operation, the volume enters the VOL_READY state."}),"\n",(0,s.jsx)(n.li,{children:"Performs the SetUp operation by calling the 'NodePublishVolume' method of the Node Service."}),"\n",(0,s.jsx)(n.li,{children:"It binds the Staging directory and mounts it to the corresponding host directory of the volume."}),"\n",(0,s.jsx)(n.li,{children:"The volume enters the PUBLISHED state, and users can now use it normally."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"across-clusters-implementation",children:"Across-clusters Implementation"}),"\n",(0,s.jsx)(n.p,{children:"Based on the above PVC, PV, StorageClass logic in a single Kubernetes cluster, and combined with the logic of creating Pod instances across clusters in Kosmos, the implementation approach for PV/PVC across clusters is as follows"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In the host cluster (Host-Cluster), the volumeBindingMode of StorageClass is set to WaitForFirstConsumer, ensuring delayed binding and configuration of PV (waiting for synchronization with the member cluster) until a Pod using PersistentVolumeClaim is created.\r\nPersistentVolumes will be selected or configured based on scheduling constraints specified in Pod, including resource requirements, node selectors, pod affinities and anti-affinities, taints, and tolerations."}),"\n",(0,s.jsx)(n.li,{children:"PVC and PV binding in the host cluster (Host-Cluster) should be consistent with the creation of Pods across clusters in Kosmos."}),"\n",(0,s.jsx)(n.li,{children:"The PV controller in the host cluster (Host-Cluster) only handles PV deletion events, and creation and updates are operated by the PV controller in the member clusters."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"flow",children:"Flow"}),"\n",(0,s.jsx)(n.p,{children:"The implementation flow of Kosmos PV/PVC is as follows:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"PV_PVC_Dynamic_Storage.png",src:t(4411).A+"",width:"1590",height:"1652"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When a Pod is created in the host cluster (Host-Cluster) and there is an associated PVC request, Kosmos will create the corresponding PVC in the member cluster based on the Pod creation event."}),"\n",(0,s.jsx)(n.li,{children:"After the PVC is created in the member cluster (Member-Cluster), the process follows the same flow as in a single Kubernetes cluster, including completion of Pod creation, PVC creation, PV creation, and PVC-PV binding."}),"\n",(0,s.jsx)(n.li,{children:"When PV is created in the member cluster (Member-Cluster), the corresponding PV controller will create the PV in the host cluster (Host-Cluster) based on the PV creation event."}),"\n",(0,s.jsx)(n.li,{children:"After successful scheduling in the member cluster (Member-Cluster) and binding of PVC and PV, the PV creation in the host cluster (Host-Cluster) completes the binding of PVC and PV."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"related",children:"Related"}),"\n",(0,s.jsx)(n.h4,{id:"scheduling-module-host-cluster",children:"Scheduling Module (Host-Cluster)"}),"\n",(0,s.jsxs)(n.p,{children:['This module can be implemented by extending the VolumeBinding plugin in the Kosmos Scheduler.\r\nIt can be achieved by using a virtual node with the taint "kosmos.io/node=true',":NoSchedule",'".']}),"\n",(0,s.jsx)(n.h4,{id:"orchestration-module",children:"Orchestration Module"}),"\n",(0,s.jsx)(n.p,{children:"This module's implementation is mainly based on the steps described in Section 3, including root_pod_controller.go, root_pvc_controller.go, leaf_pvc_controller.go, root_pv_controller.go, and leaf_pv_controller.go in the cluster-manager of Kosmos."}),"\n",(0,s.jsx)(n.h3,{id:"demo",children:"Demo"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"YAML Example:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:"script",children:'apiVersion: v1\r\nkind: PersistentVolumeClaim\r\nmetadata:\r\n  name: nginx-pvc\r\n  namespace: test-new\r\nspec:\r\n  accessModes:\r\n  - ReadWriteOnce\r\n  resources:\r\n    requests:\r\n      storage: 1Gi\r\n  storageClassName: openebs-hostpath\r\n---\r\napiVersion: apps/v1\r\nkind: Deployment\r\nmetadata:\r\n  name: nginx-new\r\n  namespace: test-new\r\nspec:\r\n  selector:\r\n    matchLabels:\r\n      app: nginx\r\n  replicas: 1\r\n  template:\r\n    metadata:\r\n      labels:\r\n        app: nginx\r\n      deletionGracePeriodSeconds: 30\r\n    spec:\r\n      affinity:\r\n        nodeAffinity:\r\n          requiredDuringSchedulingIgnoredDuringExecution:\r\n            nodeSelectorTerms:\r\n              - matchExpressions:\r\n                  - key: kubernetes.io/hostname\r\n                    operator: In\r\n                    values:\r\n                      - kosmos-cluster38\r\n      tolerations:\r\n      - key: "kosmos.io/node"\r\n        operator: "Equal"\r\n        value: "true"\r\n        effect: "NoSchedule"\r\n      containers:\r\n      - name: nginx\r\n        image: registry.paas/cnp/nginx:1.14-alpine\r\n        ports:\r\n        - containerPort: 80\r\n        volumeMounts:\r\n        - name: data\r\n          mountPath: /data\r\n      volumes:\r\n      - name: data\r\n        persistentVolumeClaim:\r\n          claimName: "nginx-pvc"\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Executing the creation operation in the Host cluster:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:"script",children:"[root@kosmos-control-cluster ylc]# kubectl apply -f test.yaml\r\npersistentvolumeclaim/nginx-pvc created\r\ndeployment.apps/nginx-new created\r\n[root@kosmos-control-cluster ylc]# kubectl get all -n test-new\r\nNAME                             READY   STATUS    RESTARTS   AGE\r\npod/nginx-new-5677468b6c-ns9k2   0/1     Pending   0          5s\r\n\r\nNAME                        READY   UP-TO-DATE   AVAILABLE   AGE\r\ndeployment.apps/nginx-new   0/1     1            0           5s\r\n\r\nNAME                                   DESIRED   CURRENT   READY   AGE\r\nreplicaset.apps/nginx-new-5677468b6c   1         1         0       5s\r\n[root@kosmos-control-cluster ylc]# kubectl get all -n test-new -owide\r\nNAME                             READY   STATUS    RESTARTS   AGE   IP              NODE               NOMINATED NODE   READINESS GATES\r\npod/nginx-new-5677468b6c-ns9k2   1/1     Running   0          11s   10.*.*.252   kosmos-cluster38   <none>           <none>\r\n\r\nNAME                        READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES                                SELECTOR\r\ndeployment.apps/nginx-new   1/1     1            1           11s   nginx        nginx:1.14-alpine   app=nginx\r\n\r\nNAME                                   DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES                                SELECTOR\r\nreplicaset.apps/nginx-new-5677468b6c   1         1         1       11s   nginx        nginx:1.14-alpine   app=nginx,pod-template-hash=56774\r\n[root@kosmos-control-cluster ylc]# kubectl get pvc -n test-new\r\nNAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS       AGE\r\nnginx-pvc   Bound    pvc-ad86ef86-23c1-407e-a8e7-0b3e44d36254   1Gi        RWO            openebs-hostpath   21s\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Querying the status in the Member cluster:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:"script",children:"[root@cluster38 ~]# kubectl get all -n test-new\r\nNAME                             READY   STATUS    RESTARTS   AGE\r\npod/nginx-new-5677468b6c-ns9k2   1/1     Running   0          2m36s\r\n[root@cluster38 ~]# kubectl get pvc -n test-new\r\nNAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS       AGE\r\nnginx-pvc   Bound    pvc-ad86ef86-23c1-407e-a8e7-0b3e44d36254   1Gi        RWO            openebs-hostpath   2m41s\n"})}),"\n",(0,s.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"The dynamic storage implementation of PV/PVC in Kosmos needs to be extended to support global storage.\r\nThe current implementation has a smaller granularity. Further improvements and evolution are needed."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},4411:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/PV_PVC_Dynamic_Storage-0b5e75726205965064b4fb0aedbe8233.png"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);